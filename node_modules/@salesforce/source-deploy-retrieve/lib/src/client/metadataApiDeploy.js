"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const convert_1 = require("../convert");
const diagnosticUtil_1 = require("./diagnosticUtil");
const types_1 = require("./types");
const metadataTransfer_1 = require("./metadataTransfer");
const path_1 = require("path");
const metadata_registry_1 = require("../metadata-registry");
const collections_1 = require("../utils/collections");
const collections_2 = require("../collections");
class DeployResult {
    constructor(response, components) {
        this.diagnosticUtil = new diagnosticUtil_1.DiagnosticUtil('metadata');
        this.response = response;
        this.components = components;
    }
    getFileResponses() {
        // TODO: Log when messages can't be mapped to components
        const messages = this.getDeployMessages(this.response);
        const fileResponses = [];
        for (const deployedComponent of this.components.getSourceComponents()) {
            if (deployedComponent.type.children) {
                for (const child of deployedComponent.getChildren()) {
                    const childMessages = messages.get(this.key(child));
                    if (childMessages) {
                        fileResponses.push(...this.createResponses(child, childMessages));
                    }
                }
            }
            const componentMessages = messages.get(this.key(deployedComponent));
            if (componentMessages) {
                fileResponses.push(...this.createResponses(deployedComponent, componentMessages));
            }
        }
        return fileResponses;
    }
    createResponses(component, messages) {
        const { fullName, type, xml, content } = component;
        const responses = [];
        for (const message of messages) {
            const baseResponse = {
                fullName,
                type: type.name,
                state: this.getState(message),
            };
            if (baseResponse.state === types_1.ComponentStatus.Failed) {
                const diagnostic = this.diagnosticUtil.parseDeployDiagnostic(component, message);
                const response = Object.assign(baseResponse, diagnostic);
                responses.push(response);
            }
            else {
                // components with children are already taken care of through the messages,
                // so don't walk their content directories.
                if (content && !type.children) {
                    for (const filePath of component.walkContent()) {
                        const response = Object.assign({}, baseResponse, { filePath });
                        responses.push(response);
                    }
                }
                if (xml) {
                    const response = Object.assign({}, baseResponse, { filePath: xml });
                    responses.push(response);
                }
            }
        }
        return responses;
    }
    getState(message) {
        if (message.created === 'true') {
            return types_1.ComponentStatus.Created;
        }
        else if (message.changed === 'true') {
            return types_1.ComponentStatus.Changed;
        }
        else if (message.deleted === 'true') {
            return types_1.ComponentStatus.Deleted;
        }
        else if (message.success === 'false') {
            return types_1.ComponentStatus.Failed;
        }
        return types_1.ComponentStatus.Unchanged;
    }
    /**
     * Groups messages from the deploy result by component fullName and type
     */
    getDeployMessages(result) {
        const messageMap = new Map();
        const failedComponents = new collections_2.ComponentSet();
        const failureMessages = collections_1.normalizeToArray(result.details.componentFailures);
        const successMessages = collections_1.normalizeToArray(result.details.componentSuccesses);
        for (const failure of failureMessages) {
            const sanitized = this.sanitizeDeployMessage(failure);
            const componentLike = {
                fullName: sanitized.fullName,
                type: sanitized.componentType,
            };
            const key = this.key(componentLike);
            if (!messageMap.has(key)) {
                messageMap.set(key, []);
            }
            messageMap.get(key).push(sanitized);
            failedComponents.add(componentLike);
        }
        for (const success of successMessages) {
            const sanitized = this.sanitizeDeployMessage(success);
            const componentLike = {
                fullName: sanitized.fullName,
                type: sanitized.componentType,
            };
            const key = this.key(componentLike);
            // this will ensure successes aren't reported if there is a failure for
            // the same component. e.g. lwc returns failures and successes
            if (!failedComponents.has(componentLike)) {
                messageMap.set(key, [sanitized]);
            }
        }
        return messageMap;
    }
    /**
     * Fix any issues with the deploy message returned by the api.
     * TODO: remove cases if fixes are made in the api.
     */
    sanitizeDeployMessage(message) {
        switch (message.componentType) {
            case metadata_registry_1.registryData.types.lightningcomponentbundle.name:
                // remove the markup scheme from fullName
                message.fullName = message.fullName.replace(/markup:\/\/c:/, '');
                break;
            case metadata_registry_1.registryData.types.document.name:
                // strip document extension from fullName
                message.fullName = path_1.join(path_1.dirname(message.fullName), path_1.basename(message.fullName, path_1.extname(message.fullName)));
                break;
            default:
        }
        return message;
    }
    key(component) {
        const type = typeof component.type === 'string' ? component.type : component.type.name;
        return `${type}#${component.fullName}`;
    }
}
exports.DeployResult = DeployResult;
class MetadataApiDeploy extends metadataTransfer_1.MetadataTransfer {
    constructor(options) {
        super(options);
        options.apiOptions = Object.assign(Object.assign({}, MetadataApiDeploy.DEFAULT_OPTIONS.apiOptions), options.apiOptions);
        this.options = Object.assign({}, options);
    }
    pre() {
        return __awaiter(this, void 0, void 0, function* () {
            const converter = new convert_1.MetadataConverter();
            const { zipBuffer } = yield converter.convert(Array.from(this.components.getSourceComponents()), 'metadata', { type: 'zip' });
            const connection = yield this.getConnection();
            const result = yield connection.metadata.deploy(zipBuffer, this.options.apiOptions);
            this.deployId = result.id;
            return result;
        });
    }
    checkStatus(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const connection = yield this.getConnection();
            // Recasting to use the project's version of the type
            return connection.metadata.checkDeployStatus(id, true);
        });
    }
    post(result) {
        return __awaiter(this, void 0, void 0, function* () {
            return new DeployResult(result, this.components);
        });
    }
    doCancel() {
        return __awaiter(this, void 0, void 0, function* () {
            let done = true;
            if (this.deployId) {
                const connection = yield this.getConnection();
                // @ts-ignore _invoke is private on the jsforce metadata object, and cancelDeploy is not an exposed method
                done = connection.metadata._invoke('cancelDeploy', { id: this.deployId }).done;
            }
            return done;
        });
    }
}
exports.MetadataApiDeploy = MetadataApiDeploy;
MetadataApiDeploy.DEFAULT_OPTIONS = {
    apiOptions: {
        rollbackOnError: true,
        ignoreWarnings: false,
        checkOnly: false,
        singlePackage: true,
    },
};
//# sourceMappingURL=metadataApiDeploy.js.map