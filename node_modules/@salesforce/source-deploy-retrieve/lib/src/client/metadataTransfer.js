"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2021, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const core_1 = require("@salesforce/core");
const events_1 = require("events");
const errors_1 = require("../errors");
const types_1 = require("./types");
class MetadataTransfer {
    constructor({ usernameOrConnection, components, apiVersion }) {
        this.signalCancel = false;
        this.event = new events_1.EventEmitter();
        this.usernameOrConnection = usernameOrConnection;
        this.components = components;
        this.apiVersion = apiVersion;
        this.logger = core_1.Logger.childFromRoot(this.constructor.name);
    }
    /**
     * Start the metadata transfer.
     *
     * @param pollInterval Frequency in milliseconds to poll for operation status
     */
    start(pollInterval = 100) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const { id } = yield this.pre();
                const apiResult = yield this.pollStatus(id, pollInterval);
                if (!apiResult || apiResult.status === types_1.RequestStatus.Canceled) {
                    this.event.emit('cancel', apiResult);
                    return;
                }
                const sourceResult = yield this.post(apiResult);
                this.event.emit('finish', sourceResult);
                return sourceResult;
            }
            catch (e) {
                if (this.event.listenerCount('error') === 0) {
                    throw e;
                }
                this.event.emit('error', e);
            }
        });
    }
    cancel() {
        this.signalCancel = true;
    }
    onUpdate(subscriber) {
        this.event.on('update', subscriber);
    }
    onFinish(subscriber) {
        this.event.on('finish', subscriber);
    }
    onCancel(subscriber) {
        this.event.on('cancel', subscriber);
    }
    onError(subscriber) {
        this.event.on('error', subscriber);
    }
    getConnection() {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.usernameOrConnection === 'string') {
                this.usernameOrConnection = yield core_1.Connection.create({
                    authInfo: yield core_1.AuthInfo.create({ username: this.usernameOrConnection }),
                });
                if (this.apiVersion) {
                    this.usernameOrConnection.setApiVersion(this.apiVersion);
                    this.logger.debug(`Overriding apiVersion to: ${this.apiVersion}`);
                }
            }
            return this.usernameOrConnection;
        });
    }
    pollStatus(id, interval) {
        return __awaiter(this, void 0, void 0, function* () {
            let result;
            let triedOnce = false;
            try {
                while (true) {
                    if (this.signalCancel) {
                        const shouldBreak = yield this.doCancel();
                        if (shouldBreak) {
                            if (result) {
                                result.status = types_1.RequestStatus.Canceled;
                            }
                            return result;
                        }
                        this.signalCancel = false;
                    }
                    if (triedOnce) {
                        yield this.wait(interval);
                    }
                    result = yield this.checkStatus(id);
                    switch (result.status) {
                        case types_1.RequestStatus.Succeeded:
                        case types_1.RequestStatus.Canceled:
                        case types_1.RequestStatus.Failed:
                            return result;
                    }
                    this.event.emit('update', result);
                    triedOnce = true;
                }
            }
            catch (e) {
                throw new errors_1.MetadataTransferError('md_request_fail', e.message);
            }
        });
    }
    wait(interval) {
        return new Promise((resolve) => {
            setTimeout(resolve, interval);
        });
    }
}
exports.MetadataTransfer = MetadataTransfer;
//# sourceMappingURL=metadataTransfer.js.map