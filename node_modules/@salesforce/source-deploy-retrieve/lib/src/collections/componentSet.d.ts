import { MetadataApiDeploy, MetadataApiDeployOptions, MetadataApiRetrieve, MetadataApiRetrieveOptions } from '../client';
import { MetadataComponent } from '../common';
import { RegistryAccess, SourceComponent } from '../metadata-registry';
import { FromManifestOptions, PackageManifestObject, FromSourceOptions } from './types';
import { ComponentLike } from '../common/types';
import { LazyCollection } from './lazyCollection';
export declare type DeploySetOptions = Omit<MetadataApiDeployOptions, 'components'>;
export declare type RetrieveSetOptions = Omit<MetadataApiRetrieveOptions, 'components'>;
/**
 * A collection containing no duplicate metadata members (`fullName` and `type` pairs). `ComponentSets`
 * are a convinient way of constructing a unique collection of components to perform operations such as
 * deploying and retrieving.
 *
 * Multiple {@link SourceComponent}s can be present in the set and correspond to the same member.
 * This is typically the case when a component's source files are split across locations. For an example, see
 * the [multiple package directories](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_ws_mpd.htm)
 * scenario.
 */
export declare class ComponentSet extends LazyCollection<MetadataComponent> {
    static readonly WILDCARD = "*";
    private static readonly KEY_DELIMITER;
    apiVersion: string;
    private registry;
    private components;
    constructor(components?: Iterable<ComponentLike>, registry?: RegistryAccess);
    /**
     * Resolve metadata components from a file or directory path in a file system.
     *
     * @param fsPath File or directory path to resolve against
     * @returns ComponentSet of source resolved components
     */
    static fromSource(fsPath: string): ComponentSet;
    /**
     * Resolve metadata components from multiple file paths or directory paths in a file system.
     *
     * @param fsPaths File or directory paths to resolve against
     * @returns ComponentSet of source resolved components
     */
    static fromSource(fsPaths: string[]): ComponentSet;
    /**
     * Resolve metadata components from file or directory paths in a file system.
     * Customize the resolution process using an options object, such as specifying filters
     * and resolving against a different file system abstraction (see {@link TreeContainer}).
     *
     * @param options
     * @returns ComponentSet of source resolved components
     */
    static fromSource(options: FromSourceOptions): ComponentSet;
    /**
     * Create a set by reading a manifest file in xml format. Optionally, specify a file path
     * with the `resolve` option to resolve source files for the components.
     *
     * ```
     * ComponentSet.fromManifestFile('/path/to/package.xml', {
     *  resolve: '/path/to/force-app'
     * });
     * ```
     *
     * @param fsPath Path to xml file
     * @param options
     * @returns Promise of a ComponentSet
     */
    static fromManifestFile(fsPath: string, options?: FromManifestOptions): Promise<ComponentSet>;
    private static getComponentsFromManifestObject;
    /**
     * Constructs a deploy operation using the components in the set. There must be at least
     * one source-backed component in the set to create an operation.
     *
     * @param options
     * @returns Metadata API deploy operation
     */
    deploy(options: DeploySetOptions): MetadataApiDeploy;
    /**
     * Constructs a retrieve operation using the components in the set.
     *
     * @param options
     * @returns Metadata API retrieve operation
     */
    retrieve(options: RetrieveSetOptions): MetadataApiRetrieve;
    /**
     * Get an object representation of a package manifest based on the set components.
     *
     * @returns Object representation of a package manifest
     */
    getObject(): PackageManifestObject;
    /**
     * Create a manifest in xml format (package.xml) based on the set components.
     *
     * @param indentation Number of spaces to indent lines by.
     */
    getPackageXml(indentation?: number): string;
    /**
     * Get only the source-backed metadata components in the set.
     *
     * @param member Member to retrieve source-backed components for.
     * @returns Collection of source-backed components
     */
    getSourceComponents(member?: ComponentLike): LazyCollection<SourceComponent>;
    add(component: ComponentLike): void;
    /**
     * Tests whether or not a `fullName` and `type` pair is present in the set.
     *
     * A pair is considered present in the set if one of the following criteria is met:
     *
     * - The pair is directly in the set
     * - A wilcard component with the same `type` as the pair
     * - If a parent is attached to the pair and the parent is directly in the set
     * - If a parent is attached to the pair, and a wildcard component's `type` matches the parent's `type`
     *
     * @param component Component to test for membership in the set
     * @returns `true` if the component is in the set
     */
    has(component: ComponentLike): boolean;
    [Symbol.iterator](): Iterator<MetadataComponent>;
    /**
     * Each {@link SourceComponent} counts as an element in the set, even if multiple
     * ones map to the same `fullName` and `type` pair.
     *
     * @returns number of metadata components in the set
     */
    get size(): number;
    private sourceKey;
    private simpleKey;
}
