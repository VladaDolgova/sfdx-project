"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
const fast_xml_parser_1 = require("fast-xml-parser");
const client_1 = require("../client");
const common_1 = require("../common");
const errors_1 = require("../errors");
const metadata_registry_1 = require("../metadata-registry");
const lazyCollection_1 = require("./lazyCollection");
/**
 * A collection containing no duplicate metadata members (`fullName` and `type` pairs). `ComponentSets`
 * are a convinient way of constructing a unique collection of components to perform operations such as
 * deploying and retrieving.
 *
 * Multiple {@link SourceComponent}s can be present in the set and correspond to the same member.
 * This is typically the case when a component's source files are split across locations. For an example, see
 * the [multiple package directories](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/sfdx_dev_ws_mpd.htm)
 * scenario.
 */
class ComponentSet extends lazyCollection_1.LazyCollection {
    constructor(components = [], registry = new metadata_registry_1.RegistryAccess()) {
        super();
        this.components = new Map();
        this.registry = registry;
        this.apiVersion = this.registry.apiVersion;
        for (const component of components) {
            this.add(component);
        }
    }
    static fromSource(input) {
        var _a, _b;
        let fsPaths = [];
        let registry;
        let tree;
        let inclusiveFilter;
        if (Array.isArray(input)) {
            fsPaths = input;
        }
        else if (typeof input === 'object') {
            fsPaths = input.fsPaths;
            registry = (_a = input.registry, (_a !== null && _a !== void 0 ? _a : registry));
            tree = (_b = input.tree, (_b !== null && _b !== void 0 ? _b : tree));
            inclusiveFilter = input.inclusiveFilter;
        }
        else {
            fsPaths = [input];
        }
        const resolver = new metadata_registry_1.MetadataResolver(registry, tree);
        const set = new ComponentSet([], registry);
        for (const fsPath of fsPaths) {
            for (const component of resolver.getComponentsFromPath(fsPath, inclusiveFilter)) {
                set.add(component);
            }
        }
        return set;
    }
    /**
     * Create a set by reading a manifest file in xml format. Optionally, specify a file path
     * with the `resolve` option to resolve source files for the components.
     *
     * ```
     * ComponentSet.fromManifestFile('/path/to/package.xml', {
     *  resolve: '/path/to/force-app'
     * });
     * ```
     *
     * @param fsPath Path to xml file
     * @param options
     * @returns Promise of a ComponentSet
     */
    static fromManifestFile(fsPath, options = {}) {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            const registry = (_a = options.registry, (_a !== null && _a !== void 0 ? _a : new metadata_registry_1.RegistryAccess()));
            const tree = (_b = options.tree, (_b !== null && _b !== void 0 ? _b : new metadata_registry_1.NodeFSTreeContainer()));
            const shouldResolve = !!options.resolve;
            const ws = new ComponentSet(undefined, registry);
            const filterSet = new ComponentSet(undefined, registry);
            const file = yield tree.readFile(fsPath);
            const manifestObj = fast_xml_parser_1.parse(file.toString(), {
                stopNodes: ['version'],
            });
            ws.apiVersion = manifestObj.Package.version;
            for (const component of ComponentSet.getComponentsFromManifestObject(manifestObj, registry)) {
                if (shouldResolve) {
                    filterSet.add(component);
                }
                const memberIsWildcard = component.fullName === ComponentSet.WILDCARD;
                if (!memberIsWildcard || ((_c = options) === null || _c === void 0 ? void 0 : _c.literalWildcard) || !shouldResolve) {
                    ws.add(component);
                }
            }
            if (shouldResolve) {
                // if it's a string, don't iterate over the characters
                const toResolve = typeof options.resolve === 'string' ? [options.resolve] : Array.from(options.resolve);
                const components = ComponentSet.fromSource({
                    fsPaths: toResolve,
                    tree,
                    inclusiveFilter: filterSet,
                    registry,
                });
                for (const component of components) {
                    ws.add(component);
                }
            }
            return ws;
        });
    }
    static *getComponentsFromManifestObject(obj, registry) {
        const { types } = obj.Package;
        const typeMembers = Array.isArray(types) ? types : [types];
        for (const { name: typeName, members } of typeMembers) {
            const fullNames = Array.isArray(members) ? members : [members];
            for (const fullName of fullNames) {
                let type = registry.getTypeByName(typeName);
                // if there is no / delimiter and it's a type in folders, infer folder component
                if (type.folderType && !fullName.includes('/')) {
                    type = registry.getTypeByName(type.folderType);
                }
                yield {
                    fullName,
                    type,
                };
            }
        }
    }
    /**
     * Constructs a deploy operation using the components in the set. There must be at least
     * one source-backed component in the set to create an operation.
     *
     * @param options
     * @returns Metadata API deploy operation
     */
    deploy(options) {
        const toDeploy = Array.from(this.getSourceComponents());
        if (toDeploy.length === 0) {
            throw new errors_1.ComponentSetError('error_no_source_to_deploy');
        }
        const operationOptions = Object.assign({}, options, {
            components: this,
            registry: this.registry,
            apiVersion: this.apiVersion,
        });
        return new client_1.MetadataApiDeploy(operationOptions);
    }
    /**
     * Constructs a retrieve operation using the components in the set.
     *
     * @param options
     * @returns Metadata API retrieve operation
     */
    retrieve(options) {
        const operationOptions = Object.assign({}, options, {
            components: this,
            registry: this.registry,
            apiVersion: this.apiVersion,
        });
        return new client_1.MetadataApiRetrieve(operationOptions);
    }
    /**
     * Get an object representation of a package manifest based on the set components.
     *
     * @returns Object representation of a package manifest
     */
    getObject() {
        const typeMap = new Map();
        for (const key of this.components.keys()) {
            const [typeId, fullName] = key.split(ComponentSet.KEY_DELIMITER);
            let type = this.registry.getTypeByName(typeId);
            if (type.folderContentType) {
                type = this.registry.getTypeByName(type.folderContentType);
            }
            if (!typeMap.has(type.name)) {
                typeMap.set(type.name, []);
            }
            typeMap.get(type.name).push(fullName);
        }
        const typeMembers = [];
        for (const [typeName, members] of typeMap.entries()) {
            typeMembers.push({ members, name: typeName });
        }
        return {
            Package: {
                types: typeMembers,
                version: this.apiVersion,
            },
        };
    }
    /**
     * Create a manifest in xml format (package.xml) based on the set components.
     *
     * @param indentation Number of spaces to indent lines by.
     */
    getPackageXml(indentation = 4) {
        const j2x = new fast_xml_parser_1.j2xParser({
            format: true,
            indentBy: new Array(indentation + 1).join(' '),
            ignoreAttributes: false,
        });
        const toParse = this.getObject();
        toParse.Package[common_1.XML_NS_KEY] = common_1.XML_NS_URL;
        return common_1.XML_DECL.concat(j2x.parse(toParse));
    }
    /**
     * Get only the source-backed metadata components in the set.
     *
     * @param member Member to retrieve source-backed components for.
     * @returns Collection of source-backed components
     */
    getSourceComponents(member) {
        var _a;
        let iter;
        if (member) {
            // filter optimization
            const memberCollection = this.components.get(this.simpleKey(member));
            iter = ((_a = memberCollection) === null || _a === void 0 ? void 0 : _a.size) > 0 ? memberCollection.values() : [];
        }
        else {
            iter = this;
        }
        return new lazyCollection_1.LazyCollection(iter).filter((c) => c instanceof metadata_registry_1.SourceComponent);
    }
    add(component) {
        const key = this.simpleKey(component);
        if (!this.components.has(key)) {
            this.components.set(key, new Map());
        }
        if (component instanceof metadata_registry_1.SourceComponent) {
            this.components.get(key).set(this.sourceKey(component), component);
        }
    }
    /**
     * Tests whether or not a `fullName` and `type` pair is present in the set.
     *
     * A pair is considered present in the set if one of the following criteria is met:
     *
     * - The pair is directly in the set
     * - A wilcard component with the same `type` as the pair
     * - If a parent is attached to the pair and the parent is directly in the set
     * - If a parent is attached to the pair, and a wildcard component's `type` matches the parent's `type`
     *
     * @param component Component to test for membership in the set
     * @returns `true` if the component is in the set
     */
    has(component) {
        const isDirectlyInSet = this.components.has(this.simpleKey(component));
        if (isDirectlyInSet) {
            return true;
        }
        const wildcardMember = {
            fullName: ComponentSet.WILDCARD,
            type: typeof component.type === 'object' ? component.type.name : component.type,
        };
        const isIncludedInWildcard = this.components.has(this.simpleKey(wildcardMember));
        if (isIncludedInWildcard) {
            return true;
        }
        if (typeof component.type === 'object') {
            const { parent } = component;
            if (parent) {
                const parentDirectlyInSet = this.components.has(this.simpleKey(parent));
                if (parentDirectlyInSet) {
                    return true;
                }
                const wildcardKey = this.simpleKey({
                    fullName: ComponentSet.WILDCARD,
                    type: parent.type,
                });
                const parentInWildcard = this.components.has(wildcardKey);
                if (parentInWildcard) {
                    return true;
                }
            }
        }
        return false;
    }
    *[Symbol.iterator]() {
        for (const [key, sourceComponents] of this.components.entries()) {
            if (sourceComponents.size === 0) {
                const [typeName, fullName] = key.split(ComponentSet.KEY_DELIMITER);
                yield {
                    fullName,
                    type: this.registry.getTypeByName(typeName),
                };
            }
            else {
                for (const component of sourceComponents.values()) {
                    yield component;
                }
            }
        }
    }
    /**
     * Each {@link SourceComponent} counts as an element in the set, even if multiple
     * ones map to the same `fullName` and `type` pair.
     *
     * @returns number of metadata components in the set
     */
    get size() {
        let size = 0;
        for (const collection of this.components.values()) {
            // just having an entry in the parent map counts as 1
            size += collection.size === 0 ? 1 : collection.size;
        }
        return size;
    }
    sourceKey(component) {
        const { fullName, type, xml, content } = component;
        return `${type.name}${fullName}${(xml !== null && xml !== void 0 ? xml : '')}${(content !== null && content !== void 0 ? content : '')}`;
    }
    simpleKey(component) {
        const typeName = typeof component.type === 'string' ? component.type.toLowerCase().trim() : component.type.id;
        return `${typeName}${ComponentSet.KEY_DELIMITER}${component.fullName}`;
    }
}
exports.ComponentSet = ComponentSet;
ComponentSet.WILDCARD = '*';
ComponentSet.KEY_DELIMITER = '#';
//# sourceMappingURL=componentSet.js.map