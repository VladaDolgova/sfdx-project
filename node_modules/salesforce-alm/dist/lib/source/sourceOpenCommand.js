"use strict";
/*
 * Copyright (c) 2020, salesforce.com, inc.
 * All rights reserved.
 * Licensed under the BSD 3-Clause license.
 * For full license text, see LICENSE.txt file in the repo root or https://opensource.org/licenses/BSD-3-Clause
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultStrategy = exports.FlexipageStrategy = exports.StrategyFactory = exports.isSalesforceOneEnabled = exports.remapError = exports.SourceOpenOperation = exports.SourceOpenCommand = void 0;
const path = require("path");
const core_1 = require("@salesforce/core");
const request = require("request");
const OrgOpenCommand = require("../org/orgOpenCommand");
const Display = require("../force-cli/force-cli-display");
const Config = require("../force-cli/force-cli-config");
const Messages = require("../force-cli/force-cli-messages");
const logApi = require("../core/logApi");
const MetadataRegistry = require("./metadataRegistry");
let logger;
class SourceOpenCommand {
    constructor() {
        logger = logApi.child('source:open');
    }
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    validate() { }
    async execute(context) {
        if (context && context.flags && context.flags.sourcefile) {
            try {
                core_1.fs.realpathSync(context.flags.sourcefile);
                const editOp = new SourceOpenOperation(context);
                return await editOp.execute();
            }
            catch (err) {
                logger.error(err);
                throw Error(err.message);
            }
        }
        else {
            throw Error(context.command);
        }
    }
}
exports.SourceOpenCommand = SourceOpenCommand;
class SourceOpenOperation {
    constructor(context, factory) {
        this.context = context;
        if (factory) {
            this.factory = factory;
        }
    }
    set factory(factory) {
        this._factory = factory;
    }
    get factory() {
        if (this._factory === undefined) {
            try {
                const metadataFactory = new MetadataRegistry();
                this._factory = new StrategyFactory(this.context, metadataFactory);
            }
            catch (e) {
                throw remapError(e);
            }
        }
        return this._factory;
    }
    async execute() {
        try {
            const strategy = this.factory.strategize();
            const url = await strategy.open();
            if (this.context.flags.json) {
                return url;
            }
            else {
                Display.info(Messages.get('SourceOpenCommandHumanSuccess', url.orgId, url.username, url.url));
            }
        }
        catch (e) {
            throw Error(Messages.get('SourceOpenCommandHumanError', e.message));
        }
    }
}
exports.SourceOpenOperation = SourceOpenOperation;
function remapError(e) {
    const stack = e.stack;
    if (stack.includes('MetadataRegistry.getTypeDefsByExtension')) {
        return new Error(Messages.get('SourceOpenCommandUnpushedError'));
    }
    else {
        return e;
    }
}
exports.remapError = remapError;
async function isSalesforceOneEnabled(cmd, requestApi, context) {
    const localContext = Object.assign({}, context, {
        flags: {
            urlonly: true,
            path: 'one/one.app',
        },
    });
    const url = await cmd.execute(await cmd.validate(localContext));
    return new Promise((resolve) => {
        requestApi(url.url, (error, response, body) => {
            if (body && !body.includes('lightning/access/orgAccessDenied.jsp')) {
                resolve(true);
            }
            else {
                resolve(false);
            }
        });
    });
}
exports.isSalesforceOneEnabled = isSalesforceOneEnabled;
class StrategyFactory {
    constructor(context, metadataRegistry) {
        this.context = context;
        this.metadataRegistry = metadataRegistry;
    }
    strategize() {
        const absoluteFilePath = path.resolve(this.context.flags.sourcefile);
        const type = this.metadataRegistry.getTypeDefinitionByFileName(absoluteFilePath);
        if (type) {
            if (type.metadataName === 'FlexiPage') {
                return new FlexipageStrategy(this.context, new OrgOpenCommand());
            }
        }
        return new DefaultStrategy(this.context, new OrgOpenCommand());
    }
}
exports.StrategyFactory = StrategyFactory;
class FlexipageStrategy {
    constructor(context, cmd) {
        this.context = context;
        this.cmd = cmd;
    }
    async deriveFlexipageURL(flexipage) {
        const connection = await Config.getActiveConnection(this.context);
        try {
            const queryResult = await connection.tooling.query(`SELECT id FROM flexipage WHERE DeveloperName='${flexipage}'`);
            if (queryResult.totalSize === 1 && queryResult.records) {
                const record = queryResult.records[0];
                return record.Id;
            }
            else {
                return FlexipageStrategy.NO_ID;
            }
        }
        catch (err) {
            return FlexipageStrategy.NO_ID;
        }
    }
    async setUpOpenContext() {
        const openContext = Object.assign({}, this.context);
        const id = await this.deriveFlexipageURL(path.basename(this.context.flags.sourcefile, '.flexipage-meta.xml'));
        const salesforceOne = await exports.isSalesforceOneEnabled(this.cmd, request, openContext);
        if (id) {
            openContext.flags.path = `/visualEditor/appBuilder.app?pageId=${id}`;
        }
        else {
            if (salesforceOne) {
                openContext.flags.path = '/one/one.app#/setup/FlexiPageList/home';
            }
            else {
                openContext.flags.path = '_ui/flexipage/ui/FlexiPageFilterListPage';
            }
        }
        return openContext;
    }
    async open() {
        const context = await this.cmd.validate(await this.setUpOpenContext());
        return await this.cmd.execute(context);
    }
}
exports.FlexipageStrategy = FlexipageStrategy;
FlexipageStrategy.NO_ID = undefined;
class DefaultStrategy {
    constructor(context, cmd) {
        this.context = context;
        this.cmd = cmd;
    }
    async open() {
        return await this.cmd.execute(await this.cmd.validate(this.context));
    }
}
exports.DefaultStrategy = DefaultStrategy;

//# sourceMappingURL=sourceOpenCommand.js.map
